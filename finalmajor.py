# -*- coding: utf-8 -*-
"""finalmajor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1biWaj2ClXBXhBIq0RR0kJdkYndE7sJZU
"""

import os
for dirname, _, filenames in os.walk('/content/drive/MyDrive/Eye_diseases'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

train_dir="/content/drive/MyDrive/Eye_diseases"

Classes = ['Bulging_Eyes', 'Cataracts', 'Crossed_Eyes', 'Glaucoma', 'Uveitis']

import cv2
import numpy as np
train_data = []
img_size=224
def get_training_data():
    for label in  Classes:
        path=os.path.join(train_dir, label)
        class_num = Classes.index(label)
        for img in os.listdir(path):
            try:
                img_arr = cv2.imread(os.path.join(path, img))
                resized_arr = cv2.resize(img_arr, (img_size, img_size))
                train_data.append([resized_arr, class_num])
            except Exception as e:
                pass

get_training_data()

print(len(train_data))



import cv2
import os
import random
import matplotlib.pyplot as plt

# Set the path to your dataset directory
dataset_dir = '/content/drive/MyDrive/Eye_diseases'

# List the classes (subdirectories) in your dataset directory
classes = os.listdir(dataset_dir)

# Create a figure to display the 6 random images
fig, axes = plt.subplots(1, 5, figsize=(15, 5))

# Iterate over 6 random classes
for i in range(5):
    class_name = random.choice(classes)  # Randomly select a class
    class_dir = os.path.join(dataset_dir, class_name)

    # List all image files in the class directory
    images = os.listdir(class_dir)

    # Randomly select an image from the class
    image_name = random.choice(images)
    image_path = os.path.join(class_dir, image_name)

    # Read and display the selected image
    image = cv2.imread(image_path)
    image=cv2.resize(image,(224,224))
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # Convert BGR to RGB
    axes[i].imshow(image)
    axes[i].set_title(class_name)
    axes[i].axis('off')

plt.show()

for label in Classes:
    print(Classes.index(label))

x=[]
y=[]
for i,j in train_data:
  x.append(i)
  y.append(j)
x=np.array(x).reshape(-1,img_size, img_size,3)

x.shape

x=x/255.0

y=np.array(y)

print(y.shape)
print(y)

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,random_state=True,test_size=0.2)

print(x_train.shape)

print(y_test)

from tensorflow.keras.utils import to_categorical
# Assuming y_train contains integer labels (0 to 4 for 5 classes)
y_train= to_categorical(y_train, num_classes=5)

from tensorflow.keras.utils import to_categorical

# Assuming y_train contains integer labels (0 to 4 for 5 classes)
y_test = to_categorical(y_test, num_classes=5)

print("train data size=",x_train.shape)
print("test data size=",y_test.shape)

"""CNN"""

from tensorflow.keras import layers, models
from keras.models import Model
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.layers import Conv2D
from tensorflow.keras.preprocessing import image
from keras.losses import categorical_crossentropy

model2 = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(5, activation='softmax')  # Change the number of units to match your number of classes
])

# Compile the model
model2.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])

model2.summary()

cm= model2.fit(x_train, y_train, epochs=10, validation_data=(x_test, y_test))

#Evaluate the model on your test data.
test_loss, test_accuracy = model2.evaluate(x_test, y_test)
print(f"Test accuracy: {test_accuracy*100:.2f}%")

# Plot the loss
import matplotlib.pyplot as plt
plt.plot(cm.history['loss'], label='train loss')
plt.plot(cm.history['val_loss'], label='val loss')
plt.legend()
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Training and Validation Loss')
plt.savefig('LossVal_loss.png')
plt.show()

# Plot the accuracy
plt.plot(cm.history['accuracy'], label='train acc')
plt.plot(cm.history['val_accuracy'], label='val acc')
plt.legend()
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.title('Training and Validation Accuracy')
plt.savefig('AccVal_acc.png')
plt.show()

# save it as a h5 file
from tensorflow.keras.models import load_model
model2.save('cm_model.h5')

import tensorflow as tf
from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt

# Load your pre-trained cnn MobileNet model (or your custom model).
model = tf.keras.models.load_model('cm_model.h5')  # Replace 'your_model_path.h5' with the path to your trained model.

# Define a dictionary to map class indices to human-readable emotion labels.
eye_labels = {
    0: "Bulging_Eyes",
    1: "Cataracts",
    2: "Crossed_Eyes",
    3: "Glaucoma",
    4: "Uveitis"
}

# Define a function to predict the emotion label and scores from an image file path.
def predict_eye(image_path):
    img = image.load_img(image_path, target_size=(224, 224))  # Resize the image to match the input size of your model.
    x = image.img_to_array(img)
    x = np.expand_dims(x, axis=0)
    predictions = model.predict(x)
    predicted_label = eye_labels[np.argmax(predictions)]  # Get the label with the highest score.
    return predicted_label, predictions

# Define a function to display the image, predicted emotion label, and scores.
def display_image_with_eye(image_path, predicted_label, predicted_emotion_scores):
    img = image.load_img(image_path)
    plt.imshow(img)
    plt.title(f"Predicted eye disease: {predicted_label}\nfood Scores: {predicted_eye_scores}")
    plt.show()

image_path = '/content/drive/MyDrive/Eye_diseases/Bulging_Eyes/images-10.jpeg'
predicted_label, predicted_eye_scores = predict_eye(image_path)
print("Predicted eye:", predicted_label)
print("Scores:", predicted_eye_scores)

# Display the image with predicted emotion label and scores.
display_image_with_eye(image_path, predicted_label, predicted_eye_scores)

"""Mobile net

"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tensorflow import keras
from tensorflow.keras import utils
import os
from keras.layers import Flatten, Dense
from keras.models import Model
from tensorflow.keras.utils import img_to_array,load_img
from keras.preprocessing.image import  ImageDataGenerator
from keras.applications.mobilenet import MobileNet, preprocess_input
from keras.losses import categorical_crossentropy
base_model = MobileNet( input_shape=(224,224,3), include_top= False )

for layer in base_model.layers:
  layer.trainable = False


x = Flatten()(base_model.output)


x = Dense(units=5 , activation='softmax' )(x)

# creating our model.
model = Model(base_model.input, x)
#model = Model(inputs=base_model.input, outputs=output_layer)

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

model.summary()

mnet= model.fit(x_train, y_train, epochs=10, validation_data=(x_test, y_test))

#Evaluate the model on your test data.
test_loss, test_accuracy = model.evaluate(x_test, y_test)
print(f"Test accuracy: {test_accuracy*100:.2f}%")



# Plot the loss
import matplotlib.pyplot as plt
plt.plot(mnet.history['loss'], label='train loss')
plt.plot(mnet.history['val_loss'], label='val loss')
plt.legend()
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Training and Validation Loss')
plt.savefig('LossVal_loss.png')
plt.show()

# Plot the accuracy
plt.plot(mnet.history['accuracy'], label='train acc')
plt.plot(mnet.history['val_accuracy'], label='val acc')
plt.legend()
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.title('Training and Validation Accuracy')
plt.savefig('AccVal_acc.png')
plt.show()



import tensorflow as tf
from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt

# Load your pre-trained cnn MobileNet model (or your custom model).
model = tf.keras.models.load_model('mnet_model.h5')  # Replace 'your_model_path.h5' with the path to your trained model.

# Define a dictionary to map class indices to human-readable emotion labels.
eye_labels = {
    0: "Bulging_Eyes",
    1: "Cataracts",
    2: "Crossed_Eyes",
    3: "Glaucoma",
    4: "Uveitis"
}

# Define a function to predict the emotion label and scores from an image file path.
def predict_eye(image_path):
    img = image.load_img(image_path, target_size=(224, 224))  # Resize the image to match the input size of your model.
    x = image.img_to_array(img)
    x = np.expand_dims(x, axis=0)
    predictions = model.predict(x)
    predicted_label = eye_labels[np.argmax(predictions)]  # Get the label with the highest score.
    return predicted_label, predictions

# Define a function to display the image, predicted emotion label, and scores.
def display_image_with_eye(image_path, predicted_label, predicted_emotion_scores):
    img = image.load_img(image_path)
    plt.imshow(img)
    plt.title(f"Predicted eye disease: {predicted_label}\nfood Scores: {predicted_eye_scores}")
    plt.show()

image_path = '/content/drive/MyDrive/Eye_diseases/Uveitis/images-7.jpeg'
predicted_label, predicted_eye_scores = predict_eye(image_path)
print("Predicted eye:", predicted_label)
print("Scores:", predicted_eye_scores)

# Display the image with predicted emotion label and scores.
display_image_with_eye(image_path, predicted_label, predicted_eye_scores)